/*
 * generated by Xtext 2.30.0
 */
package de.fraunhofer.ipa.targetEnvironment.serializer;

import com.google.inject.Inject;
import de.fraunhofer.ipa.deployment.util.AbstractComputationAssignmentTarget;
import de.fraunhofer.ipa.deployment.util.Arm64ProcessorArchitecture;
import de.fraunhofer.ipa.deployment.util.AttributeKind;
import de.fraunhofer.ipa.deployment.util.CommunicationType;
import de.fraunhofer.ipa.deployment.util.EthernetCommunicationType;
import de.fraunhofer.ipa.deployment.util.LinuxOpertingSystemType;
import de.fraunhofer.ipa.deployment.util.MacOSOpertingSystemType;
import de.fraunhofer.ipa.deployment.util.MaximumKind;
import de.fraunhofer.ipa.deployment.util.MinimumKind;
import de.fraunhofer.ipa.deployment.util.ProcessorArchitectureType;
import de.fraunhofer.ipa.deployment.util.Property;
import de.fraunhofer.ipa.deployment.util.PropertyAttribute;
import de.fraunhofer.ipa.deployment.util.PropertyMaximun;
import de.fraunhofer.ipa.deployment.util.PropertyMinimum;
import de.fraunhofer.ipa.deployment.util.PropertyRange;
import de.fraunhofer.ipa.deployment.util.PropertySelection;
import de.fraunhofer.ipa.deployment.util.PropertyValueDouble;
import de.fraunhofer.ipa.deployment.util.PropertyValueInt;
import de.fraunhofer.ipa.deployment.util.PropertyValueString;
import de.fraunhofer.ipa.deployment.util.RangeKind;
import de.fraunhofer.ipa.deployment.util.ResourceType;
import de.fraunhofer.ipa.deployment.util.SelectionKind;
import de.fraunhofer.ipa.deployment.util.UtilPackage;
import de.fraunhofer.ipa.deployment.util.WlanCommunicationType;
import de.fraunhofer.ipa.deployment.util.X86ProcessorArchitecture;
import de.fraunhofer.ipa.targetEnvironment.services.TargetEnvironmentGrammarAccess;
import device.AbstractDeviceConfig;
import device.AddressNetworkProperty;
import device.CapabilityType;
import device.CommunicationConnection;
import device.ComputationDeviceType;
import device.ConnectionProperty;
import device.DevicePackage;
import device.DeviceProperty;
import device.DeviceSet;
import device.DeviceType;
import device.DeviceTypeRef;
import device.InterfaceNetworkProperty;
import device.NetworkConnection;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import targetEnvironment.ComputationDeviceInstance;
import targetEnvironment.ConfigConnection;
import targetEnvironment.ConfigConnectionProperty;
import targetEnvironment.ConfigDeviceProperty;
import targetEnvironment.ConnectedDevice;
import targetEnvironment.DeviceInstance;
import targetEnvironment.TargetDeployEnviroment;
import targetEnvironment.TargetEnvironment;
import targetEnvironment.TargetEnvironmentPackage;

@SuppressWarnings("all")
public class TargetEnvironmentSemanticSequencer extends DeviceSemanticSequencer {

    @Inject
    private TargetEnvironmentGrammarAccess grammarAccess;

    @Override
    public void sequence(ISerializationContext context, EObject semanticObject) {
        EPackage epackage = semanticObject.eClass().getEPackage();
        ParserRule rule = context.getParserRule();
        Action action = context.getAssignedAction();
        Set<Parameter> parameters = context.getEnabledBooleanParameters();
        if (epackage == DevicePackage.eINSTANCE)
            switch (semanticObject.eClass().getClassifierID()) {
            case DevicePackage.ABSTRACT_DEVICE_CONFIG:
                sequence_AbstractDeviceConfig(context, (AbstractDeviceConfig) semanticObject);
                return;
            case DevicePackage.ADDRESS_NETWORK_PROPERTY:
                sequence_AddressNetworkProperty(context, (AddressNetworkProperty) semanticObject);
                return;
            case DevicePackage.CAPABILITY_TYPE:
                sequence_CapabilityType(context, (CapabilityType) semanticObject);
                return;
            case DevicePackage.COMMUNICATION_CONNECTION:
                sequence_CommunicationConnection(context, (CommunicationConnection) semanticObject);
                return;
            case DevicePackage.COMPUTATION_DEVICE_TYPE:
                sequence_ComputationDeviceType(context, (ComputationDeviceType) semanticObject);
                return;
            case DevicePackage.CONNECTION_PROPERTY:
                sequence_ConnectionProperty(context, (ConnectionProperty) semanticObject);
                return;
            case DevicePackage.DEVICE_PROPERTY:
                sequence_DeviceProperty(context, (DeviceProperty) semanticObject);
                return;
            case DevicePackage.DEVICE_SET:
                sequence_DeviceSet(context, (DeviceSet) semanticObject);
                return;
            case DevicePackage.DEVICE_TYPE:
                sequence_DeviceType_Impl(context, (DeviceType) semanticObject);
                return;
            case DevicePackage.DEVICE_TYPE_REF:
                sequence_DeviceTypeRef(context, (DeviceTypeRef) semanticObject);
                return;
            case DevicePackage.INTERFACE_NETWORK_PROPERTY:
                sequence_InterfaceNetworkProperty(context, (InterfaceNetworkProperty) semanticObject);
                return;
            case DevicePackage.NETWORK_CONNECTION:
                sequence_NetworkConnection(context, (NetworkConnection) semanticObject);
                return;
            }
        else if (epackage == TargetEnvironmentPackage.eINSTANCE)
            switch (semanticObject.eClass().getClassifierID()) {
            case TargetEnvironmentPackage.COMPUTATION_DEVICE_INSTANCE:
                sequence_ComputationDeviceInstance(context, (ComputationDeviceInstance) semanticObject);
                return;
            case TargetEnvironmentPackage.CONFIG_CONNECTION:
                sequence_ConfigConnection(context, (ConfigConnection) semanticObject);
                return;
            case TargetEnvironmentPackage.CONFIG_CONNECTION_PROPERTY:
                sequence_ConfigConnectionProperty(context, (ConfigConnectionProperty) semanticObject);
                return;
            case TargetEnvironmentPackage.CONFIG_DEVICE_PROPERTY:
                sequence_ConfigDeviceProperty(context, (ConfigDeviceProperty) semanticObject);
                return;
            case TargetEnvironmentPackage.CONNECTED_DEVICE:
                sequence_ConnectedDevice(context, (ConnectedDevice) semanticObject);
                return;
            case TargetEnvironmentPackage.DEVICE_INSTANCE:
                sequence_DeviceInstance(context, (DeviceInstance) semanticObject);
                return;
            case TargetEnvironmentPackage.TARGET_DEPLOY_ENVIROMENT:
                sequence_TargetDeployEnviroment(context, (TargetDeployEnviroment) semanticObject);
                return;
            case TargetEnvironmentPackage.TARGET_ENVIRONMENT:
                sequence_TargetEnvironment(context, (TargetEnvironment) semanticObject);
                return;
            }
        else if (epackage == UtilPackage.eINSTANCE)
            switch (semanticObject.eClass().getClassifierID()) {
            case UtilPackage.ABSTRACT_COMPUTATION_ASSIGNMENT_TARGET:
                sequence_AbstractComputationAssignmentTarget(context, (AbstractComputationAssignmentTarget) semanticObject);
                return;
            case UtilPackage.ARM64_PROCESSOR_ARCHITECTURE:
                sequence_Arm64ProcessorArchitecture(context, (Arm64ProcessorArchitecture) semanticObject);
                return;
            case UtilPackage.ATTRIBUTE_KIND:
                sequence_AttributeKind(context, (AttributeKind) semanticObject);
                return;
            case UtilPackage.COMMUNICATION_TYPE:
                sequence_CommunicationType(context, (CommunicationType) semanticObject);
                return;
            case UtilPackage.ETHERNET_COMMUNICATION_TYPE:
                sequence_EthernetCommunicationType(context, (EthernetCommunicationType) semanticObject);
                return;
            case UtilPackage.LINUX_OPERTING_SYSTEM_TYPE:
                sequence_LinuxOpertingSystemType(context, (LinuxOpertingSystemType) semanticObject);
                return;
            case UtilPackage.MAC_OS_OPERTING_SYSTEM_TYPE:
                sequence_MacOSOpertingSystemType(context, (MacOSOpertingSystemType) semanticObject);
                return;
            case UtilPackage.MAXIMUM_KIND:
                sequence_MaximumKind(context, (MaximumKind) semanticObject);
                return;
            case UtilPackage.MINIMUM_KIND:
                sequence_MinimumKind(context, (MinimumKind) semanticObject);
                return;
            case UtilPackage.PROCESSOR_ARCHITECTURE_TYPE:
                sequence_ProcessorArchitectureType(context, (ProcessorArchitectureType) semanticObject);
                return;
            case UtilPackage.PROPERTY:
                sequence_Property(context, (Property) semanticObject);
                return;
            case UtilPackage.PROPERTY_ATTRIBUTE:
                sequence_PropertyAttribute(context, (PropertyAttribute) semanticObject);
                return;
            case UtilPackage.PROPERTY_MAXIMUN:
                sequence_PropertyMaximun(context, (PropertyMaximun) semanticObject);
                return;
            case UtilPackage.PROPERTY_MINIMUM:
                sequence_PropertyMinimum(context, (PropertyMinimum) semanticObject);
                return;
            case UtilPackage.PROPERTY_RANGE:
                sequence_PropertyRange(context, (PropertyRange) semanticObject);
                return;
            case UtilPackage.PROPERTY_SELECTION:
                sequence_PropertySelection(context, (PropertySelection) semanticObject);
                return;
            case UtilPackage.PROPERTY_VALUE_DOUBLE:
                sequence_PropertyValueDouble(context, (PropertyValueDouble) semanticObject);
                return;
            case UtilPackage.PROPERTY_VALUE_INT:
                sequence_PropertyValueInt(context, (PropertyValueInt) semanticObject);
                return;
            case UtilPackage.PROPERTY_VALUE_STRING:
                sequence_PropertyValueString(context, (PropertyValueString) semanticObject);
                return;
            case UtilPackage.RANGE_KIND:
                sequence_RangeKind(context, (RangeKind) semanticObject);
                return;
            case UtilPackage.RESOURCE_TYPE:
                sequence_ResourceType(context, (ResourceType) semanticObject);
                return;
            case UtilPackage.SELECTION_KIND:
                sequence_SelectionKind(context, (SelectionKind) semanticObject);
                return;
            case UtilPackage.WLAN_COMMUNICATION_TYPE:
                sequence_WlanCommunicationType(context, (WlanCommunicationType) semanticObject);
                return;
            case UtilPackage.X86_PROCESSOR_ARCHITECTURE:
                sequence_X86ProcessorArchitecture(context, (X86ProcessorArchitecture) semanticObject);
                return;
            }
        if (errorAcceptor != null)
            errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
    }

    /**
     * <pre>
     * Contexts:
     *     AbstractDeviceInstance returns ComputationDeviceInstance
     *     ComputationDeviceInstance returns ComputationDeviceInstance
     *
     * Constraint:
     *     (name=EString refDeviceType=[ComputationDeviceType|EString])
     * </pre>
     */
    protected void sequence_ComputationDeviceInstance(ISerializationContext context, ComputationDeviceInstance semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, TargetEnvironmentPackage.Literals.ABSTRACT_DEVICE_INSTANCE__NAME) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TargetEnvironmentPackage.Literals.ABSTRACT_DEVICE_INSTANCE__NAME));
            if (transientValues.isValueTransient(semanticObject, TargetEnvironmentPackage.Literals.COMPUTATION_DEVICE_INSTANCE__REF_DEVICE_TYPE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TargetEnvironmentPackage.Literals.COMPUTATION_DEVICE_INSTANCE__REF_DEVICE_TYPE));
        }
        SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
        feeder.accept(grammarAccess.getComputationDeviceInstanceAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
        feeder.accept(grammarAccess.getComputationDeviceInstanceAccess().getRefDeviceTypeComputationDeviceTypeEStringParserRuleCall_5_0_1(), semanticObject.eGet(TargetEnvironmentPackage.Literals.COMPUTATION_DEVICE_INSTANCE__REF_DEVICE_TYPE, false));
        feeder.finish();
    }


    /**
     * <pre>
     * Contexts:
     *     ConfigConnectionProperty returns ConfigConnectionProperty
     *
     * Constraint:
     *     (name=EString refConnectionProperty=[ConnectionProperty|EString] value=PropertyValue?)
     * </pre>
     */
    protected void sequence_ConfigConnectionProperty(ISerializationContext context, ConfigConnectionProperty semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     ConfigConnection returns ConfigConnection
     *
     * Constraint:
     *     (name=EString connectDevice+=ConnectedDevice+)
     * </pre>
     */
    protected void sequence_ConfigConnection(ISerializationContext context, ConfigConnection semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     ConfigDeviceProperty returns ConfigDeviceProperty
     *
     * Constraint:
     *     (name=EString from=[DeviceProperty|EString] value=PropertyValue)
     * </pre>
     */
    protected void sequence_ConfigDeviceProperty(ISerializationContext context, ConfigDeviceProperty semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, TargetEnvironmentPackage.Literals.CONFIG_DEVICE_PROPERTY__NAME) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TargetEnvironmentPackage.Literals.CONFIG_DEVICE_PROPERTY__NAME));
            if (transientValues.isValueTransient(semanticObject, TargetEnvironmentPackage.Literals.CONFIG_DEVICE_PROPERTY__FROM) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TargetEnvironmentPackage.Literals.CONFIG_DEVICE_PROPERTY__FROM));
            if (transientValues.isValueTransient(semanticObject, TargetEnvironmentPackage.Literals.CONFIG_DEVICE_PROPERTY__VALUE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TargetEnvironmentPackage.Literals.CONFIG_DEVICE_PROPERTY__VALUE));
        }
        SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
        feeder.accept(grammarAccess.getConfigDevicePropertyAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
        feeder.accept(grammarAccess.getConfigDevicePropertyAccess().getFromDevicePropertyEStringParserRuleCall_5_0_1(), semanticObject.eGet(TargetEnvironmentPackage.Literals.CONFIG_DEVICE_PROPERTY__FROM, false));
        feeder.accept(grammarAccess.getConfigDevicePropertyAccess().getValuePropertyValueParserRuleCall_7_0(), semanticObject.getValue());
        feeder.finish();
    }


    /**
     * <pre>
     * Contexts:
     *     ConnectedDevice returns ConnectedDevice
     *
     * Constraint:
     *     (refDevice=[AbstractDeviceInstance|EString] refConnection=[CommunicationConnection|EString] properties+=ConfigConnectionProperty*)
     * </pre>
     */
    protected void sequence_ConnectedDevice(ISerializationContext context, ConnectedDevice semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     AbstractDeviceInstance returns DeviceInstance
     *     DeviceInstance returns DeviceInstance
     *
     * Constraint:
     *     (name=EString refDeviceType=[DeviceType|EString] configDeviceProperty+=ConfigDeviceProperty*)
     * </pre>
     */
    protected void sequence_DeviceInstance(ISerializationContext context, DeviceInstance semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     Description returns TargetDeployEnviroment
     *     TargetDeployEnviroment returns TargetDeployEnviroment
     *
     * Constraint:
     *     (name=EString (includeDevice+=ComputationDeviceInstance+ includeDevice+=DeviceInstance+)? configConnection+=ConfigConnection*)
     * </pre>
     */
    protected void sequence_TargetDeployEnviroment(ISerializationContext context, TargetDeployEnviroment semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     TargetEnvironment returns TargetEnvironment
     *
     * Constraint:
     *     type+=Description
     * </pre>
     */
    protected void sequence_TargetEnvironment(ISerializationContext context, TargetEnvironment semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


}
