/*
 * generated by Xtext 2.30.0
 */
package de.fraunhofer.ipa.deployment.generator

import de.fraunhofer.ipa.deployment.util.RunTimeType
import deploymentPlan.AbstractComputationAssignment
import deploymentPlan.AbstractDeploymentPlan
import deploymentPlan.ConfigSoftwareComponent
import deploymentPlan.DeploymentPlan
import java.util.List
import java.util.stream.Collectors
import javax.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */



class PlanGenerator extends AbstractGenerator {

    @Inject
    extension RepoInstallCompiler

    @Inject
    extension DockerFileCompiler

    @Inject
    extension GitHubWorkflowCompiler

    @Inject
    extension AnsibleCompiler

    @Inject
    extension DockerComposeCompiler

    @Inject
    extension DeploymentHelper

    var NamingHelper namingHelper = new NamingHelper

    def DockerfilePath(String assignmentFolderPath){
        return String.format("%s/Dockerfile", assignmentFolderPath)
    }

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val plans = resource.allContents.toIterable.filter(AbstractDeploymentPlan)
        generateFiles(plans.toList, fsa)
//        for(plan: plans){
//                System.out.println(plan.name)
//            var assignments = plan.realize.realization
//            for (assignment : assignments){
//                System.out.println(assignment.executedBy.name)
//                var configSoftwareComponents =  (assignment as ImplementationAssignment).softwareComponent
//                var impls = configSoftwareComponents.stream.map[component].collect(Collectors.toList())
//                System.out.println(impls)
//                if(plan instanceof DeploymentPlan){
//                    fsa.generateFile(String.format("%s/%s_%s.repos", plan.getName(),plan.getName(), assignment.executedBy.name),
//                                            plan.RepoInstallCompiler(impls))
//                }
//
//
//                var exec = configSoftwareComponents.stream.map[executionConfiguration].collect(Collectors.toList)
//                System.out.println(exec)
//            }
//        }

    }

    def generateFiles(List<AbstractDeploymentPlan> plans, IFileSystemAccess2 fsa){
      for(plan: plans){
        namingHelper.relativePlanFolderPath = plan.name
        generateWorkflow(plan, fsa)
        generateAnsible(plan, fsa)
        var assignments = plan.realize.realizations
        for (assignment : assignments){
            generateRosInstall(assignment, plan, fsa)
            generateDockerFile(assignment, plan, fsa)
        }
        generateDockerComposeFile(assignments, fsa)
      }
    }

      def generateRosInstall(AbstractComputationAssignment assignment, AbstractDeploymentPlan plan, IFileSystemAccess2 fsa) {
        var scs = assignment.softwareComponents
        var impls = scs.map[it as ConfigSoftwareComponent].stream.map[component].collect(Collectors.toList())
        fsa.generateFile(
                namingHelper.getReposFile(assignment.name, assignment.executedBy.name),
            (plan as DeploymentPlan).RepoInstallCompiler(impls)
        )
      }

        def generateDockerFile(AbstractComputationAssignment assignment, AbstractDeploymentPlan plan, IFileSystemAccess2 fsa) {
            if(assignment.runtimeType == RunTimeType.CONTAINER){
            var impls = assignment.softwareComponents.map[it as ConfigSoftwareComponent].stream.map[component].collect(Collectors.toList())
            fsa.generateFile(namingHelper.getRelativeDockerfilePath(assignment.name),
                assignment.dockerFileCompiler
                )
            }
        }

        def generateWorkflow(AbstractDeploymentPlan plan, IFileSystemAccess2 fsa) {
            fsa.generateFile(
                namingHelper.getGithubReuseableWorkflowPath,
                ReusableWorkflow)
            fsa.generateFile(
                namingHelper.getGithubWorkflowPath(plan.name),
                plan.gitHubWorkflowCompiler(
                    namingHelper.absoluteDefaultGithubReuseableWorkflowPath, namingHelper)
            )
        }

        def generateDockerComposeFile(List<AbstractComputationAssignment> assignments, IFileSystemAccess2 fsa){

          var assPerExecutors = collectAssignmentPerExecutor(assignments)
            assPerExecutors.forEach[compDev, assignmentList|
                fsa.generateFile(
                namingHelper.getCyclonConfigPath(compDev.name),
                cycloneDDSConfig)
            fsa.generateFile(
                    namingHelper.getDockerComposePath(compDev.name),
                assignmentList.dockerComposeCompiler(compDev))]
        }


        def generateAnsible(AbstractDeploymentPlan plan, IFileSystemAccess2 fsa) {
            var ansibleNaming = new AnsibleNamingHelper
            ansibleNaming.relativeAnsibleFolerPath = plan.name
            fsa.generateFile(
                ansibleNaming.getConfigFilePath,
                ansibleConfig
                )
            fsa.generateFile(
                ansibleNaming.getInventoryFilePath,
                plan.deployTo.inventory
                )
            fsa.generateFile(
              ansibleNaming.playbookFilePath,
              plan.playbook(ansibleNaming)
                )
            fsa.generateFile(
                ansibleNaming.getTaskMainFilePath(ansibleNaming.taskCommonFolderPath),
                ansibleNaming.taskRunCommonTasks
                )
            fsa.generateFile(
              ansibleNaming.taskInstallDockerFilePath,
              taskCheckInstallDocker
                )
            fsa.generateFile(
                ansibleNaming.getTaskMainFilePath(ansibleNaming.taskDeploySoftwareFolderPath),
                namingHelper.taskDeploySoftware
                )
        }
}
