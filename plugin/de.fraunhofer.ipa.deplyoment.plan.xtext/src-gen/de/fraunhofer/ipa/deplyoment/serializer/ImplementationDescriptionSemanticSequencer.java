/*
 * generated by Xtext 2.30.0
 */
package de.fraunhofer.ipa.deplyoment.serializer;

import com.google.inject.Inject;
import de.fraunhofer.ipa.deployment.serializer.UtilSemanticSequencer;
import de.fraunhofer.ipa.deployment.util.AbstractComputationAssignmentTarget;
import de.fraunhofer.ipa.deployment.util.Arm64ProcessorArchitecture;
import de.fraunhofer.ipa.deployment.util.AttributeKind;
import de.fraunhofer.ipa.deployment.util.CommunicationType;
import de.fraunhofer.ipa.deployment.util.Description;
import de.fraunhofer.ipa.deployment.util.EthernetCommunicationType;
import de.fraunhofer.ipa.deployment.util.LinuxOpertingSystemType;
import de.fraunhofer.ipa.deployment.util.MacOSOpertingSystemType;
import de.fraunhofer.ipa.deployment.util.MaximumKind;
import de.fraunhofer.ipa.deployment.util.MinimumKind;
import de.fraunhofer.ipa.deployment.util.ProcessorArchitectureType;
import de.fraunhofer.ipa.deployment.util.Property;
import de.fraunhofer.ipa.deployment.util.PropertyAttribute;
import de.fraunhofer.ipa.deployment.util.PropertyMaximun;
import de.fraunhofer.ipa.deployment.util.PropertyMinimum;
import de.fraunhofer.ipa.deployment.util.PropertyRange;
import de.fraunhofer.ipa.deployment.util.PropertySelection;
import de.fraunhofer.ipa.deployment.util.PropertyValueDouble;
import de.fraunhofer.ipa.deployment.util.PropertyValueInt;
import de.fraunhofer.ipa.deployment.util.PropertyValueString;
import de.fraunhofer.ipa.deployment.util.RangeKind;
import de.fraunhofer.ipa.deployment.util.ResourceType;
import de.fraunhofer.ipa.deployment.util.SelectionKind;
import de.fraunhofer.ipa.deployment.util.UtilPackage;
import de.fraunhofer.ipa.deployment.util.WlanCommunicationType;
import de.fraunhofer.ipa.deployment.util.X86ProcessorArchitecture;
import de.fraunhofer.ipa.deplyoment.services.ImplementationDescriptionGrammarAccess;
import implementationDescription.DeviceRequirement;
import implementationDescription.HWSWParemeter;
import implementationDescription.ImplementationDescription;
import implementationDescription.ImplementationDescriptionPackage;
import implementationDescription.SoftwareComponent;
import implementationDescription.SoftwareConfigurationRequirement;
import implementationDescription.SoftwareExecutionParemeter;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;

@SuppressWarnings("all")
public class ImplementationDescriptionSemanticSequencer extends UtilSemanticSequencer {

    @Inject
    private ImplementationDescriptionGrammarAccess grammarAccess;

    @Override
    public void sequence(ISerializationContext context, EObject semanticObject) {
        EPackage epackage = semanticObject.eClass().getEPackage();
        ParserRule rule = context.getParserRule();
        Action action = context.getAssignedAction();
        Set<Parameter> parameters = context.getEnabledBooleanParameters();
        if (epackage == ImplementationDescriptionPackage.eINSTANCE)
            switch (semanticObject.eClass().getClassifierID()) {
            case ImplementationDescriptionPackage.DEVICE_REQUIREMENT:
                sequence_DeviceRequirement(context, (DeviceRequirement) semanticObject);
                return;
            case ImplementationDescriptionPackage.HWSW_PAREMETER:
                sequence_HWSWParemeter(context, (HWSWParemeter) semanticObject);
                return;
            case ImplementationDescriptionPackage.IMPLEMENTATION_DESCRIPTION:
                sequence_ImplementationDescription(context, (ImplementationDescription) semanticObject);
                return;
            case ImplementationDescriptionPackage.SOFTWARE_COMPONENT:
                sequence_SoftwareComponent(context, (SoftwareComponent) semanticObject);
                return;
            case ImplementationDescriptionPackage.SOFTWARE_CONFIGURATION_REQUIREMENT:
                sequence_SoftwareConfigurationRequirement(context, (SoftwareConfigurationRequirement) semanticObject);
                return;
            case ImplementationDescriptionPackage.SOFTWARE_EXECUTION_PAREMETER:
                sequence_SoftwareExecutionParemeter(context, (SoftwareExecutionParemeter) semanticObject);
                return;
            }
        else if (epackage == UtilPackage.eINSTANCE)
            switch (semanticObject.eClass().getClassifierID()) {
            case UtilPackage.ABSTRACT_COMPUTATION_ASSIGNMENT_TARGET:
                sequence_AbstractComputationAssignmentTarget(context, (AbstractComputationAssignmentTarget) semanticObject);
                return;
            case UtilPackage.ARM64_PROCESSOR_ARCHITECTURE:
                sequence_Arm64ProcessorArchitecture(context, (Arm64ProcessorArchitecture) semanticObject);
                return;
            case UtilPackage.ATTRIBUTE_KIND:
                sequence_AttributeKind(context, (AttributeKind) semanticObject);
                return;
            case UtilPackage.COMMUNICATION_TYPE:
                sequence_CommunicationType(context, (CommunicationType) semanticObject);
                return;
            case UtilPackage.DESCRIPTION:
                sequence_Description(context, (Description) semanticObject);
                return;
            case UtilPackage.ETHERNET_COMMUNICATION_TYPE:
                sequence_EthernetCommunicationType(context, (EthernetCommunicationType) semanticObject);
                return;
            case UtilPackage.LINUX_OPERTING_SYSTEM_TYPE:
                sequence_LinuxOpertingSystemType(context, (LinuxOpertingSystemType) semanticObject);
                return;
            case UtilPackage.MAC_OS_OPERTING_SYSTEM_TYPE:
                sequence_MacOSOpertingSystemType(context, (MacOSOpertingSystemType) semanticObject);
                return;
            case UtilPackage.MAXIMUM_KIND:
                sequence_MaximumKind(context, (MaximumKind) semanticObject);
                return;
            case UtilPackage.MINIMUM_KIND:
                sequence_MinimumKind(context, (MinimumKind) semanticObject);
                return;
            case UtilPackage.PROCESSOR_ARCHITECTURE_TYPE:
                sequence_ProcessorArchitectureType(context, (ProcessorArchitectureType) semanticObject);
                return;
            case UtilPackage.PROPERTY:
                sequence_Property(context, (Property) semanticObject);
                return;
            case UtilPackage.PROPERTY_ATTRIBUTE:
                sequence_PropertyAttribute(context, (PropertyAttribute) semanticObject);
                return;
            case UtilPackage.PROPERTY_MAXIMUN:
                sequence_PropertyMaximun(context, (PropertyMaximun) semanticObject);
                return;
            case UtilPackage.PROPERTY_MINIMUM:
                sequence_PropertyMinimum(context, (PropertyMinimum) semanticObject);
                return;
            case UtilPackage.PROPERTY_RANGE:
                sequence_PropertyRange(context, (PropertyRange) semanticObject);
                return;
            case UtilPackage.PROPERTY_SELECTION:
                sequence_PropertySelection(context, (PropertySelection) semanticObject);
                return;
            case UtilPackage.PROPERTY_VALUE_DOUBLE:
                sequence_PropertyValueDouble(context, (PropertyValueDouble) semanticObject);
                return;
            case UtilPackage.PROPERTY_VALUE_INT:
                sequence_PropertyValueInt(context, (PropertyValueInt) semanticObject);
                return;
            case UtilPackage.PROPERTY_VALUE_STRING:
                sequence_PropertyValueString(context, (PropertyValueString) semanticObject);
                return;
            case UtilPackage.RANGE_KIND:
                sequence_RangeKind(context, (RangeKind) semanticObject);
                return;
            case UtilPackage.RESOURCE_TYPE:
                sequence_ResourceType(context, (ResourceType) semanticObject);
                return;
            case UtilPackage.SELECTION_KIND:
                sequence_SelectionKind(context, (SelectionKind) semanticObject);
                return;
            case UtilPackage.WLAN_COMMUNICATION_TYPE:
                sequence_WlanCommunicationType(context, (WlanCommunicationType) semanticObject);
                return;
            case UtilPackage.X86_PROCESSOR_ARCHITECTURE:
                sequence_X86ProcessorArchitecture(context, (X86ProcessorArchitecture) semanticObject);
                return;
            }
        if (errorAcceptor != null)
            errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
    }

    /**
     * <pre>
     * Contexts:
     *     ExecutionRequirement returns DeviceRequirement
     *     DeviceRequirement returns DeviceRequirement
     *
     * Constraint:
     *     (type=EString parameter+=HWSWParemeter*)
     * </pre>
     */
    protected void sequence_DeviceRequirement(ISerializationContext context, DeviceRequirement semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     ExecutionProperty returns HWSWParemeter
     *     HWSWParemeter returns HWSWParemeter
     *
     * Constraint:
     *     (name=EString kind=AttributeKind description=EString? (value+=PropertyValue value+=PropertyValue*)?)
     * </pre>
     */
    protected void sequence_HWSWParemeter(ISerializationContext context, HWSWParemeter semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     ImplementationDescription returns ImplementationDescription
     *
     * Constraint:
     *     (name=EString (softwareDependency+=EString softwareDependency+=EString*)? includeSoftwareComponent+=SoftwareComponent+)
     * </pre>
     */
    protected void sequence_ImplementationDescription(ISerializationContext context, ImplementationDescription semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     SoftwareComponent returns SoftwareComponent
     *
     * Constraint:
     *     (name=EString path=EString executionRequirement+=ExecutionRequirement*)
     * </pre>
     */
    protected void sequence_SoftwareComponent(ISerializationContext context, SoftwareComponent semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     ExecutionRequirement returns SoftwareConfigurationRequirement
     *     SoftwareConfigurationRequirement returns SoftwareConfigurationRequirement
     *
     * Constraint:
     *     parameter+=SoftwareExecutionParemeter+
     * </pre>
     */
    protected void sequence_SoftwareConfigurationRequirement(ISerializationContext context, SoftwareConfigurationRequirement semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


    /**
     * <pre>
     * Contexts:
     *     ExecutionProperty returns SoftwareExecutionParemeter
     *     SoftwareExecutionParemeter returns SoftwareExecutionParemeter
     *
     * Constraint:
     *     (name=EString kind=AttributeKind description=EString? (value+=PropertyValue value+=PropertyValue*)?)
     * </pre>
     */
    protected void sequence_SoftwareExecutionParemeter(ISerializationContext context, SoftwareExecutionParemeter semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }


}
