/*
 * generated by Xtext 2.36.0
 */
package de.fraunhofer.ipa.targetEnvironment.serializer;

import com.google.inject.Inject;
import de.fraunhofer.ipa.deployment.serializer.UtilSemanticSequencer;
import de.fraunhofer.ipa.deployment.util.AbstractComputationAssignmentTarget;
import de.fraunhofer.ipa.deployment.util.AttributeKind;
import de.fraunhofer.ipa.deployment.util.CommunicationType;
import de.fraunhofer.ipa.deployment.util.EthernetCommunicationType;
import de.fraunhofer.ipa.deployment.util.LinuxDistributionValue;
import de.fraunhofer.ipa.deployment.util.LinuxOpertingSystem;
import de.fraunhofer.ipa.deployment.util.MacOSOpertingSystem;
import de.fraunhofer.ipa.deployment.util.MaximumKind;
import de.fraunhofer.ipa.deployment.util.MinimumKind;
import de.fraunhofer.ipa.deployment.util.NameOperatingSystemProperty;
import de.fraunhofer.ipa.deployment.util.OperatingSystemResouce;
import de.fraunhofer.ipa.deployment.util.ProcessorArchitectureValue;
import de.fraunhofer.ipa.deployment.util.ProcessorResouceType;
import de.fraunhofer.ipa.deployment.util.Property;
import de.fraunhofer.ipa.deployment.util.PropertyAttribute;
import de.fraunhofer.ipa.deployment.util.PropertyMaximun;
import de.fraunhofer.ipa.deployment.util.PropertyMinimum;
import de.fraunhofer.ipa.deployment.util.PropertyRange;
import de.fraunhofer.ipa.deployment.util.PropertySelection;
import de.fraunhofer.ipa.deployment.util.PropertyValueDouble;
import de.fraunhofer.ipa.deployment.util.PropertyValueInt;
import de.fraunhofer.ipa.deployment.util.PropertyValueList;
import de.fraunhofer.ipa.deployment.util.PropertyValueString;
import de.fraunhofer.ipa.deployment.util.RangeKind;
import de.fraunhofer.ipa.deployment.util.Resource;
import de.fraunhofer.ipa.deployment.util.ResourceType;
import de.fraunhofer.ipa.deployment.util.SelectionKind;
import de.fraunhofer.ipa.deployment.util.UbuntuVersionValue;
import de.fraunhofer.ipa.deployment.util.UsbCommunicationType;
import de.fraunhofer.ipa.deployment.util.UtilPackage;
import de.fraunhofer.ipa.deployment.util.VersionOperatingSystemProperty;
import de.fraunhofer.ipa.deployment.util.WlanCommunicationType;
import de.fraunhofer.ipa.targetEnvironment.services.DeviceGrammarAccess;
import device.AddressNetworkProperty;
import device.ArchitectureProcessorProperty;
import device.CommunicationConnection;
import device.ComputationDeviceType;
import device.ConnectionProperty;
import device.CoreProcessorProperty;
import device.DNSServerNetworkProperty;
import device.DevicePackage;
import device.DeviceResource;
import device.DeviceSet;
import device.DeviceType;
import device.DeviceVolumeUsbProperty;
import device.GatewayNetworkProperty;
import device.IdentityNameNetworkProperty;
import device.InterfaceNetworkProperty;
import device.MacAddressNetworkProperty;
import device.NetworkConnection;
import device.PortNetworkProperty;
import device.ProcessorResouce;
import device.SubnetMaskNetworkProperty;
import device.UsbConnection;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;

@SuppressWarnings("all")
public class DeviceSemanticSequencer extends UtilSemanticSequencer {

  @Inject
  private DeviceGrammarAccess grammarAccess;

  @Override
  public void sequence(ISerializationContext context, EObject semanticObject) {
    EPackage epackage = semanticObject.eClass().getEPackage();
    ParserRule rule = context.getParserRule();
    Action action = context.getAssignedAction();
    Set<Parameter> parameters = context.getEnabledBooleanParameters();
    if (epackage == DevicePackage.eINSTANCE)
      switch (semanticObject.eClass().getClassifierID()) {
      case DevicePackage.ADDRESS_NETWORK_PROPERTY:
        sequence_AddressNetworkProperty(context, (AddressNetworkProperty) semanticObject);
        return;
      case DevicePackage.ARCHITECTURE_PROCESSOR_PROPERTY:
        sequence_ArchitectureProcessorProperty(context, (ArchitectureProcessorProperty) semanticObject);
        return;
      case DevicePackage.COMMUNICATION_CONNECTION:
        sequence_CommunicationConnection(context, (CommunicationConnection) semanticObject);
        return;
      case DevicePackage.COMPUTATION_DEVICE_TYPE:
        sequence_ComputationDeviceType(context, (ComputationDeviceType) semanticObject);
        return;
      case DevicePackage.CONNECTION_PROPERTY:
        sequence_ConnectionProperty(context, (ConnectionProperty) semanticObject);
        return;
      case DevicePackage.CORE_PROCESSOR_PROPERTY:
        sequence_CoreProcessorProperty(context, (CoreProcessorProperty) semanticObject);
        return;
      case DevicePackage.DNS_SERVER_NETWORK_PROPERTY:
        sequence_DNSServerNetworkProperty(context, (DNSServerNetworkProperty) semanticObject);
        return;
      case DevicePackage.DEVICE_RESOURCE:
        sequence_DeviceResource(context, (DeviceResource) semanticObject);
        return;
      case DevicePackage.DEVICE_SET:
        sequence_DeviceSet(context, (DeviceSet) semanticObject);
        return;
      case DevicePackage.DEVICE_TYPE:
        sequence_DeviceType_Impl(context, (DeviceType) semanticObject);
        return;
      case DevicePackage.DEVICE_VOLUME_USB_PROPERTY:
        sequence_DeviceVolumeUsbProperty(context, (DeviceVolumeUsbProperty) semanticObject);
        return;
      case DevicePackage.GATEWAY_NETWORK_PROPERTY:
        sequence_GatewayNetworkProperty(context, (GatewayNetworkProperty) semanticObject);
        return;
      case DevicePackage.IDENTITY_NAME_NETWORK_PROPERTY:
        sequence_IdentityNameNetworkProperty(context, (IdentityNameNetworkProperty) semanticObject);
        return;
      case DevicePackage.INTERFACE_NETWORK_PROPERTY:
        sequence_InterfaceNetworkProperty(context, (InterfaceNetworkProperty) semanticObject);
        return;
      case DevicePackage.MAC_ADDRESS_NETWORK_PROPERTY:
        sequence_MacAddressNetworkProperty(context, (MacAddressNetworkProperty) semanticObject);
        return;
      case DevicePackage.NETWORK_CONNECTION:
        sequence_NetworkConnection(context, (NetworkConnection) semanticObject);
        return;
      case DevicePackage.PORT_NETWORK_PROPERTY:
        sequence_PortNetworkProperty(context, (PortNetworkProperty) semanticObject);
        return;
      case DevicePackage.PROCESSOR_RESOUCE:
        sequence_ProcessorResouce(context, (ProcessorResouce) semanticObject);
        return;
      case DevicePackage.SUBNET_MASK_NETWORK_PROPERTY:
        sequence_SubnetMaskNetworkProperty(context, (SubnetMaskNetworkProperty) semanticObject);
        return;
      case DevicePackage.USB_CONNECTION:
        sequence_UsbConnection(context, (UsbConnection) semanticObject);
        return;
      }
    else if (epackage == UtilPackage.eINSTANCE)
      switch (semanticObject.eClass().getClassifierID()) {
      case UtilPackage.ABSTRACT_COMPUTATION_ASSIGNMENT_TARGET:
        sequence_AbstractComputationAssignmentTarget(context, (AbstractComputationAssignmentTarget) semanticObject);
        return;
      case UtilPackage.ATTRIBUTE_KIND:
        sequence_AttributeKind(context, (AttributeKind) semanticObject);
        return;
      case UtilPackage.COMMUNICATION_TYPE:
        sequence_CommunicationType(context, (CommunicationType) semanticObject);
        return;
      case UtilPackage.ETHERNET_COMMUNICATION_TYPE:
        sequence_EthernetCommunicationType(context, (EthernetCommunicationType) semanticObject);
        return;
      case UtilPackage.LINUX_DISTRIBUTION_VALUE:
        sequence_LinuxDistributionValue(context, (LinuxDistributionValue) semanticObject);
        return;
      case UtilPackage.LINUX_OPERTING_SYSTEM:
        sequence_LinuxOpertingSystem(context, (LinuxOpertingSystem) semanticObject);
        return;
      case UtilPackage.MAC_OS_OPERTING_SYSTEM:
        sequence_MacOSOpertingSystem(context, (MacOSOpertingSystem) semanticObject);
        return;
      case UtilPackage.MAXIMUM_KIND:
        sequence_MaximumKind(context, (MaximumKind) semanticObject);
        return;
      case UtilPackage.MINIMUM_KIND:
        sequence_MinimumKind(context, (MinimumKind) semanticObject);
        return;
      case UtilPackage.NAME_OPERATING_SYSTEM_PROPERTY:
        sequence_NameOperatingSystemProperty(context, (NameOperatingSystemProperty) semanticObject);
        return;
      case UtilPackage.OPERATING_SYSTEM_RESOUCE:
        sequence_OperatingSystemResouce(context, (OperatingSystemResouce) semanticObject);
        return;
      case UtilPackage.PROCESSOR_ARCHITECTURE_VALUE:
        sequence_ProcessorArchitectureValue(context, (ProcessorArchitectureValue) semanticObject);
        return;
      case UtilPackage.PROCESSOR_RESOUCE_TYPE:
        sequence_ProcessorResouceType(context, (ProcessorResouceType) semanticObject);
        return;
      case UtilPackage.PROPERTY:
        sequence_Property(context, (Property) semanticObject);
        return;
      case UtilPackage.PROPERTY_ATTRIBUTE:
        sequence_PropertyAttribute(context, (PropertyAttribute) semanticObject);
        return;
      case UtilPackage.PROPERTY_MAXIMUN:
        sequence_PropertyMaximun(context, (PropertyMaximun) semanticObject);
        return;
      case UtilPackage.PROPERTY_MINIMUM:
        sequence_PropertyMinimum(context, (PropertyMinimum) semanticObject);
        return;
      case UtilPackage.PROPERTY_RANGE:
        sequence_PropertyRange(context, (PropertyRange) semanticObject);
        return;
      case UtilPackage.PROPERTY_SELECTION:
        sequence_PropertySelection(context, (PropertySelection) semanticObject);
        return;
      case UtilPackage.PROPERTY_VALUE_DOUBLE:
        sequence_PropertyValueDouble(context, (PropertyValueDouble) semanticObject);
        return;
      case UtilPackage.PROPERTY_VALUE_INT:
        sequence_PropertyValueInt(context, (PropertyValueInt) semanticObject);
        return;
      case UtilPackage.PROPERTY_VALUE_LIST:
        sequence_PropertyValueList(context, (PropertyValueList) semanticObject);
        return;
      case UtilPackage.PROPERTY_VALUE_STRING:
        sequence_PropertyValueString(context, (PropertyValueString) semanticObject);
        return;
      case UtilPackage.RANGE_KIND:
        sequence_RangeKind(context, (RangeKind) semanticObject);
        return;
      case UtilPackage.RESOURCE:
        sequence_Resource(context, (Resource) semanticObject);
        return;
      case UtilPackage.RESOURCE_TYPE:
        sequence_ResourceType(context, (ResourceType) semanticObject);
        return;
      case UtilPackage.SELECTION_KIND:
        sequence_SelectionKind(context, (SelectionKind) semanticObject);
        return;
      case UtilPackage.UBUNTU_VERSION_VALUE:
        sequence_UbuntuVersionValue(context, (UbuntuVersionValue) semanticObject);
        return;
      case UtilPackage.USB_COMMUNICATION_TYPE:
        sequence_UsbCommunicationType(context, (UsbCommunicationType) semanticObject);
        return;
      case UtilPackage.VERSION_OPERATING_SYSTEM_PROPERTY:
        sequence_VersionOperatingSystemProperty(context, (VersionOperatingSystemProperty) semanticObject);
        return;
      case UtilPackage.WLAN_COMMUNICATION_TYPE:
        sequence_WlanCommunicationType(context, (WlanCommunicationType) semanticObject);
        return;
      }
    if (errorAcceptor != null)
      errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
  }

  /**
   * <pre>
   * Contexts:
   *     AbstractNetworkProperty returns AddressNetworkProperty
   *     AddressNetworkProperty returns AddressNetworkProperty
   *
   * Constraint:
   *     (name='ip_address' kind=AttributeKind description=EString? value=PropertyValue?)
   * </pre>
   */
  protected void sequence_AddressNetworkProperty(ISerializationContext context, AddressNetworkProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstracProcessorProperty returns ArchitectureProcessorProperty
   *     ArchitectureProcessorProperty returns ArchitectureProcessorProperty
   *
   * Constraint:
   *     (name='processor_architecture' kind=AttributeKind description=EString? value=PropertyValue?)
   * </pre>
   */
  protected void sequence_ArchitectureProcessorProperty(ISerializationContext context, ArchitectureProcessorProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractCommunicationConnection returns CommunicationConnection
   *     CommunicationConnection returns CommunicationConnection
   *
   * Constraint:
   *     (name=EString type=CommunicationType properties+=ConnectionProperty*)
   * </pre>
   */
  protected void sequence_CommunicationConnection(ISerializationContext context, CommunicationConnection semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     DeviceType returns ComputationDeviceType
   *     ComputationDeviceType returns ComputationDeviceType
   *
   * Constraint:
   *     (
   *         name=EString
   *         deviceResource+=DeviceResource*
   *         (computationResource+=AbstractComputationResource computationResource+=AbstractComputationResource*)?
   *         communicationConnection+=AbstractCommunicationConnection*
   *     )
   * </pre>
   */
  protected void sequence_ComputationDeviceType(ISerializationContext context, ComputationDeviceType semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     ConnectionProperty returns ConnectionProperty
   *
   * Constraint:
   *     (name=EString kind=AttributeKind description=EString? value=PropertyValue?)
   * </pre>
   */
  protected void sequence_ConnectionProperty(ISerializationContext context, ConnectionProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstracProcessorProperty returns CoreProcessorProperty
   *     CoreProcessorProperty returns CoreProcessorProperty
   *
   * Constraint:
   *     (name='core_number' kind=AttributeKind description=EString? value=PropertyValue?)
   * </pre>
   */
  protected void sequence_CoreProcessorProperty(ISerializationContext context, CoreProcessorProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractNetworkProperty returns DNSServerNetworkProperty
   *     DNSServerNetworkProperty returns DNSServerNetworkProperty
   *
   * Constraint:
   *     (name='dns_server' kind=SelectionKind description=EString? (value+=PropertyValue value+=PropertyValue*)?)
   * </pre>
   */
  protected void sequence_DNSServerNetworkProperty(ISerializationContext context, DNSServerNetworkProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     DeviceResource returns DeviceResource
   *
   * Constraint:
   *     (name=EString type=AbstractResouceType (properties+=AbstractProperty properties+=AbstractProperty*)?)
   * </pre>
   */
  protected void sequence_DeviceResource(ISerializationContext context, DeviceResource semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     DeviceSet returns DeviceSet
   *     Description returns DeviceSet
   *
   * Constraint:
   *     (device+=DeviceType device+=DeviceType*)
   * </pre>
   */
  protected void sequence_DeviceSet(ISerializationContext context, DeviceSet semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     DeviceType returns DeviceType
   *     DeviceType_Impl returns DeviceType
   *
   * Constraint:
   *     (name=EString deviceResource+=DeviceResource* communicationConnection+=AbstractCommunicationConnection*)
   * </pre>
   */
  protected void sequence_DeviceType_Impl(ISerializationContext context, DeviceType semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractUsbProperty returns DeviceVolumeUsbProperty
   *     DeviceVolumeUsbProperty returns DeviceVolumeUsbProperty
   *
   * Constraint:
   *     (name='device_volume' kind=SelectionKind description=EString? (value+=PropertyValue value+=PropertyValue*)?)
   * </pre>
   */
  protected void sequence_DeviceVolumeUsbProperty(ISerializationContext context, DeviceVolumeUsbProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractNetworkProperty returns GatewayNetworkProperty
   *     GatewayNetworkProperty returns GatewayNetworkProperty
   *
   * Constraint:
   *     (name='gateway' kind=AttributeKind description=EString? value=PropertyValue?)
   * </pre>
   */
  protected void sequence_GatewayNetworkProperty(ISerializationContext context, GatewayNetworkProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractNetworkProperty returns IdentityNameNetworkProperty
   *     IdentityNameNetworkProperty returns IdentityNameNetworkProperty
   *
   * Constraint:
   *     (name='identity_name' kind=AttributeKind description=EString?)
   * </pre>
   */
  protected void sequence_IdentityNameNetworkProperty(ISerializationContext context, IdentityNameNetworkProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractNetworkProperty returns InterfaceNetworkProperty
   *     InterfaceNetworkProperty returns InterfaceNetworkProperty
   *
   * Constraint:
   *     (name='interface_name' kind=AttributeKind description=EString? value=PropertyValue?)
   * </pre>
   */
  protected void sequence_InterfaceNetworkProperty(ISerializationContext context, InterfaceNetworkProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractNetworkProperty returns MacAddressNetworkProperty
   *     MacAddressNetworkProperty returns MacAddressNetworkProperty
   *
   * Constraint:
   *     (name='mac_address' kind=AttributeKind description=EString?)
   * </pre>
   */
  protected void sequence_MacAddressNetworkProperty(ISerializationContext context, MacAddressNetworkProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractCommunicationConnection returns NetworkConnection
   *     NetworkConnection returns NetworkConnection
   *
   * Constraint:
   *     (name=EString type=NetworkCommunicationType properties+=AbstractNetworkProperty*)
   * </pre>
   */
  protected void sequence_NetworkConnection(ISerializationContext context, NetworkConnection semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractNetworkProperty returns PortNetworkProperty
   *     PortNetworkProperty returns PortNetworkProperty
   *
   * Constraint:
   *     (name='port' kind=AttributeKind description=EString? value=PropertyValueInt?)
   * </pre>
   */
  protected void sequence_PortNetworkProperty(ISerializationContext context, PortNetworkProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractComputationResource returns ProcessorResouce
   *     ProcessorResouce returns ProcessorResouce
   *
   * Constraint:
   *     (name=EString type=ProcessorResouceType properties+=AbstracProcessorProperty*)
   * </pre>
   */
  protected void sequence_ProcessorResouce(ISerializationContext context, ProcessorResouce semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractNetworkProperty returns SubnetMaskNetworkProperty
   *     SubnetMaskNetworkProperty returns SubnetMaskNetworkProperty
   *
   * Constraint:
   *     (name='subnet_mask' kind=AttributeKind description=EString? value=PropertyValue?)
   * </pre>
   */
  protected void sequence_SubnetMaskNetworkProperty(ISerializationContext context, SubnetMaskNetworkProperty semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


  /**
   * <pre>
   * Contexts:
   *     AbstractCommunicationConnection returns UsbConnection
   *     UsbConnection returns UsbConnection
   *
   * Constraint:
   *     (name=EString type=UsbCommunicationType properties+=AbstractUsbProperty*)
   * </pre>
   */
  protected void sequence_UsbConnection(ISerializationContext context, UsbConnection semanticObject) {
    genericSequencer.createSequence(context, semanticObject);
  }


}
